// AUTOMATICALLY GENERATED BY MIDDLECRAFT
/* Allows plugins to access server functions without needing to link the actual server Jar. */
package net.minecraft.server;

public abstract class Packet17AddToInventory{
	// FIELDS
	private java.util.List A;
	private java.util.List B;
	private java.util.TreeSet C;
	private java.util.Set D;
	private long E;
	private long F;
	private HashEntry2 G;
	private Packet1Login H;
	private java.util.ArrayList I;
	private int J;
	private java.util.Set K;
	private int L;
	private java.util.List M;
	public boolean a;
	public java.util.List b;
	public java.util.List c;
	public java.util.List d;
	public long e;
	public int f;
	protected int g;
	protected int h;
	public boolean i;
	protected int j;
	public int k;
	public java.util.Random l;
	public int m;
	public int n;
	public int o;
	public boolean p;
	public final EntityMinecart q;
	protected java.util.List r;
	public java.io.File s;
	public java.io.File t;
	public long u;
	public long v;
	public final java.lang.String w;
	public boolean x;
	static int y;
	public boolean z;
	
	// METHODS
	
	/**
	 * 
	 */
	public MaterialTransparent a()
	
	/**
	 * Gets the closest player to the point within the specified distance (distance can be set to less than 0 to not limit the distance). Args: x, y, z, dist
	 */
	public BlockLog getClosestPlayer(double a, double b, double c, double d)
	
	/**
	 * Play a sound effect. Many many parameters for this function. Not sure what they do, but a classic call is : (double)i + 0.5D, (double)j + 0.5D, (double)k + 0.5D, 'random.door_open', 1.0F, world.rand.nextFloat() * 0.1F + 0.9F with i,j,k position of the block.
	 */
	public void playSoundEffect(double a, double b, double c, java.lang.String d, float e, float f)
	
	/**
	 * Returns the amount of skylight subtracted for the current time
	 */
	public int calculateSkylightSubtracted(float a)
	
	/**
	 * 
	 */
	public int a(int a, int b)
	
	/**
	 * Returns the block ID at coords x,y,z
	 */
	public int getBlockId(int a, int b, int c)
	
	/**
	 * Sets the block to the specified blockID at the block coordinates Args x, y, z, blockID
	 */
	public boolean setBlock(int a, int b, int c, int d)
	
	/**
	 * *
	 */
	public boolean setBlockAndMetadata(int a, int b, int c, int d, int e)
	
	/**
	 * Checks between a min and max all the chunks inbetween actually exist. Args: minX, minY, minZ, maxX, maxY, maxZ
	 */
	public boolean checkChunksExist(int a, int b, int c, int d, int e, int f)
	
	/**
	 * *
	 */
	public boolean canBlockBePlacedAt(int a, int b, int c, int d, boolean e)
	
	/**
	 * Sets the TileEntity for a given block in X, Y, Z coordinates
	 */
	public void setBlockTileEntity(int a, int b, int c, EntitySnowball d)
	
	/**
	 * Gets the light value of a block location. This is the actual function that gets the value and has a bool flag that  indicates if its a half step block to get the maximum light value of a direct neighboring block (left, right, forward, back, and up)
	 */
	public int getBlockLightValue(int a, int b, int c, boolean d)
	
	/**
	 * 
	 */
	public BlockFlower a(NoiseGenerator2 a, NoiseGenerator2 b)
	
	/**
	 * *
	 */
	public BlockFlower rayTraceBlocks(NoiseGenerator2 a, NoiseGenerator2 b, boolean c)
	
	/**
	 * 
	 */
	public float a(NoiseGenerator2 a, IUpdatePlayerListBox b)
	
	/**
	 * 
	 */
	public void a(SpawnerAnimals a)
	
	/**
	 * Returns saved light value without taking into account the time of day.  Either looks in the sky light map or block light map based on the enumSkyBlock arg.
	 */
	public int getSavedLightValue(NBTTagList a, int b, int c, int d)
	
	/**
	 * Called when a neighboring block's light value has changed and its propagated light might change this blocks value.  Args: enumSkyBlock, x, y, z, propagatedLight
	 */
	public void neighborLightPropagationChanged(NBTTagList a, int b, int c, int d, int e)
	
	/**
	 * 
	 */
	public void a(NBTTagList a, int b, int c, int d, int e, int f, int g)
	
	/**
	 * 
	 */
	public void a(NBTTagList a, int b, int c, int d, int e, int f, int g, boolean h)
	
	/**
	 * *
	 */
	public boolean checkIfAABBIsClear(IUpdatePlayerListBox a)
	
	/**
	 * Returns true if the given bounding box contains the given material
	 */
	public boolean isMaterialInBB(IUpdatePlayerListBox a, la b)
	
	/**
	 * 
	 */
	public boolean a(IUpdatePlayerListBox a, la b, IMobs c)
	
	/**
	 * Called when an entity is spawned in the world. This includes players.
	 */
	public boolean entityJoinedWorld(IMobs a)
	
	/**
	 * 
	 */
	public void a(IMobs a, byte b)
	
	/**
	 * Gets the closest player to the entity within the specified distance (if distance is less than 0 then ignored). Args: entity, dist
	 */
	public BlockLog getClosestPlayerToEntity(IMobs a, double b)
	
	/**
	 * *
	 */
	public ItemSnowball createExplosion(IMobs a, double b, double c, double d, float e)
	
	/**
	 * 
	 */
	public ItemSnowball a(IMobs a, double b, double c, double d, float e, boolean f)
	
	/**
	 * *
	 */
	public ItemTool getEntityPathToXYZ(IMobs a, int b, int c, int d, float e)
	
	/**
	 * Returns a list of bounding boxes that collide with aabb excluding the passed in entity's collision. Args: entity, aabb
	 */
	public java.util.List getCollidingBoundingBoxes(IMobs a, IUpdatePlayerListBox b)
	
	/**
	 * *
	 */
	public ItemTool getPathToEntity(IMobs a, IMobs b, float c)
	
	/**
	 * Plays a sound at the entity's position. Args: entity, sound, unknown1, unknown2
	 */
	public void playSoundAtEntity(IMobs a, java.lang.String b, float c, float d)
	
	/**
	 * *
	 */
	public void updateEntityWithOptionalForce(IMobs a, boolean b)
	
	/**
	 * 
	 */
	public boolean a(BlockLog a, int b, int c, int d)
	
	/**
	 * 
	 */
	protected HashEntry2 a(java.io.File a)
	
	/**
	 * Counts how many entities of an entity class exist in the world. Args: entityClass
	 */
	public int countEntities(java.lang.Class a)
	
	/**
	 * Returns all entities of the specified class type which intersect with the AABB. Args: entityClass, aabb
	 */
	public java.util.List getEntitiesWithinAABB(java.lang.Class a, IUpdatePlayerListBox b)
	
	/**
	 * Spawns a particle.  Args particleName, x, y, z, velX, velY, velZ
	 */
	public void spawnParticle(java.lang.String a, double b, double c, double d, double e, double f, double g)
	
	/**
	 * Plays a record at the specified coordinates of the specified name. Args: recordName, x, y, z
	 */
	public void playRecord(java.lang.String a, int b, int c, int d)
	
	/**
	 * 
	 */
	public void a(java.util.List a)
	
	/**
	 * Runs through the list of updates to run and ticks them
	 */
	public boolean TickUpdates(boolean a)
	
	/**
	 * *
	 */
	public void saveWorld(boolean a, ChunkCoordIntPair b)
	
	/**
	 * Checks whether its daytime by seeing if the light subtracted from the skylight is less than 4
	 */
	public boolean isDaytime()
	
	/**
	 * *
	 */
	public float getCelestialAngle(float a)
	
	/**
	 * Returns a chunk looked up by block coordinates. Args: x, y
	 */
	public kx getChunkFromBlockCoords(int a, int b)
	
	/**
	 * Returns the block metadata at coords x,y,z
	 */
	public int getBlockMetadata(int a, int b, int c)
	
	/**
	 * Sets the blocks metadata and if set will then notify blocks that this block changed. Args: x, y, z, metadata
	 */
	public void setBlockMetadataWithNotify(int a, int b, int c, int d)
	
	/**
	 * *
	 */
	public boolean setBlockAndMetadataWithNotify(int a, int b, int c, int d, int e)
	
	/**
	 * 
	 */
	public void b(int a, int b, int c, int d, int e, int f)
	
	/**
	 * 
	 */
	public void b(int a, int b, int c, EntitySnowball d)
	
	/**
	 * Sets the light value either into the sky map or block map depending on if enumSkyBlock is set to sky or block. Args: enumSkyBlock, x, y, z, lightValue
	 */
	public void setLightValue(NBTTagList a, int b, int c, int d, int e)
	
	/**
	 * Returns if any of the blocks within the aabb are liquids. Args: aabb
	 */
	public boolean getIsAnyLiquid(IUpdatePlayerListBox a)
	
	/**
	 * 
	 */
	public boolean b(IUpdatePlayerListBox a, la b)
	
	/**
	 * *
	 */
	protected void obtainEntitySkin(IMobs a)
	
	/**
	 * Will get all entities within the specified AABB excluding the one passed into it. Args: entityToExclude, aabb
	 */
	public java.util.List getEntitiesWithinAABBExcludingEntity(IMobs a, IUpdatePlayerListBox b)
	
	/**
	 * 
	 */
	public void b(java.util.List a)
	
	/**
	 * 
	 */
	public void c()
	
	/**
	 * Returns back a chunk looked up by chunk coordinates Args: x, y
	 */
	public kx getChunkFromChunkCoords(int a, int b)
	
	/**
	 * Returns the block's material.
	 */
	public la getBlockMaterial(int a, int b, int c)
	
	/**
	 * Set the metadata of a block in global coordinates
	 */
	public boolean setBlockMetadata(int a, int b, int c, int d)
	
	/**
	 * 
	 */
	public byte[] c(int a, int b, int c, int d, int e, int f)
	
	/**
	 * *
	 */
	public boolean isBoundingBoxBurning(IUpdatePlayerListBox a)
	
	/**
	 * *
	 */
	protected void releaseEntitySkin(IMobs a)
	
	/**
	 * 
	 */
	public boolean d()
	
	/**
	 * Returns the y coordinate with a block in it at this x, z coordinate
	 */
	public int getHeightValue(int a, int b)
	
	/**
	 * Returns if the block at the specified coordinates allow attachment Args: x, y, z
	 */
	public boolean doesBlockAllowAttachment(int a, int b, int c)
	
	/**
	 * Sets a block and notifies relevant systems with the block change  Args: x, y, z, blockID
	 */
	public boolean setBlockWithNotify(int a, int b, int c, int d)
	
	/**
	 * 
	 */
	public void d(IMobs a)
	
	/**
	 * Called on construction of the World class to setup the initial skylight values
	 */
	public void calculateInitialSkylight()
	
	/**
	 * 
	 */
	public int e(int a, int b)
	
	/**
	 * 
	 */
	public boolean e(int a, int b, int c)
	
	/**
	 * The block type change and need to notify other systems  Args: x, y, z, blockID
	 */
	protected void notifyBlockChange(int a, int b, int c, int d)
	
	/**
	 * 
	 */
	public void e(IMobs a)
	
	/**
	 * Runs a single tick for the world
	 */
	public void tick()
	
	/**
	 * Returns whether a chunk exists at chunk coordinates x, y
	 */
	private boolean chunkExists(int a, int b)
	
	/**
	 * *
	 */
	public boolean blockExists(int a, int b, int c)
	
	/**
	 * 
	 */
	public void f(int a, int b, int c, int d)
	
	/**
	 * *
	 */
	public void updateEntity(IMobs a)
	
	/**
	 * 
	 */
	protected void g()
	
	/**
	 * *
	 */
	public void markBlockNeedsUpdate(int a, int b, int c)
	
	/**
	 * Notifies neighboring blocks that this specified block changed  Args: x, y, z, blockID
	 */
	public void notifyBlocksOfNeighborChange(int a, int b, int c, int d)
	
	/**
	 * 
	 */
	public void h()
	
	/**
	 * Checks if the specified block is able to see the sky
	 */
	public boolean canBlockSeeTheSky(int a, int b, int c)
	
	/**
	 * Schedules a specific block to be to ticked by its specified delay. Args: x, y, z, blockID
	 */
	public void scheduleBlockUpdate(int a, int b, int c, int d)
	
	/**
	 * *
	 */
	private void saveLevel()
	
	/**
	 * Gets the light value of a block location
	 */
	public int getBlockLightValue(int a, int b, int c)
	
	/**
	 * Is this block powering in the specified direction Args: x, y, z, direction
	 */
	public boolean isBlockProvidingPowerTo(int a, int b, int c, int d)
	
	/**
	 * Determines if a block can see the sky or not, but if the proper chunk does not already exist, it does not create a new one.
	 */
	public boolean canExistingBlockSeeTheSky(int a, int b, int c)
	
	/**
	 * Is a block next to you getting powered (if its an attachable block) or is it providing power directly to you.  Args: x, y, z, direction
	 */
	public boolean isBlockIndirectlyProvidingPowerTo(int a, int b, int c, int d)
	
	/**
	 * Returns how bright the block is shown as which is the block's light value looked up in a lookup table (light values aren't linear for brihgtness). Args: x, y, z
	 */
	public float getLightBrightness(int a, int b, int c)
	
	/**
	 * Notifies a block that one of its neighbor change to the specified type Args: x, y, z, blockID
	 */
	private void notifyBlockOfNeighborChange(int a, int b, int c, int d)
	
	/**
	 * Returns the TileEntity associated with a given block in X,Y,Z coordinates, or null if no TileEntity exists
	 */
	public EntitySnowball getBlockTileEntity(int a, int b, int c)
	
	/**
	 * 
	 */
	public void m(int a, int b, int c)
	
	/**
	 * Whether one of the neighboring blocks is putting power into this block. Args: x, y, z
	 */
	public boolean isBlockGettingPowered(int a, int b, int c)
	
	/**
	 * Used to see if one of the blocks next to you or your block is getting power from a neighboring block. Used by items like TNT or Doors so they don't have redstone going straight into them.  Args: x, y, z
	 */
	public boolean isBlockIndirectlyGettingPowered(int a, int b, int c)

}
